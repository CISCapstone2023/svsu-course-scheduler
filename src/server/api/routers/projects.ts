import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "src/server/api/trpc";
import { Prisma } from "@prisma/client";
import {
  IProjectOrganizedColumnRow,
  organizeColumnRows,
  type IProjectOrganizedColumnFromClient,
} from "src/validation/projects";
import xlsx from "node-xlsx";
import { invert } from "lodash";
import { componentShapes } from "react-daisyui/dist/constants";
import Faculty from "src/pages/dashboard/[scheduleId]/faculty/Faculty";
type ExcelDataColumns = Array<Array<string | undefined>>;

//import validation next
const scheduleWithRevisions = Prisma.validator<Prisma.ScheduleArgs>()({
  include: { revisions: true },
});
type ScheduleWithRevisions = Prisma.ScheduleGetPayload<
  typeof scheduleWithRevisions
>;
export const projectsRouter = createTRPCRouter({
  // ScheduleRevision -------------------------------------------------------------------------------------

  //Get all ScheduleRevisions and display list of schedule revisions sorted by time, desecnding
  getAllScheduleRevisions: protectedProcedure
    .input(
      z.object({
        search: z.string(),
        page: z.number().default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      let scheduleResult: ScheduleWithRevisions[] = [];

      //Do we have a search query
      if (input.search != "") {
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          where: {
            revisions: {
              every: { name: { contains: input.search } },
            },
          },
          include: {
            revisions: true,
          },
        });
      } else {
        //If we don't have a search query don't worry about the filter
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          include: {
            revisions: {
              orderBy: {
                updatedAt: "desc",
              },
            },
          },
        });
      }

      //Return the data
      return {
        result: scheduleResult.map((s) => {
          const [main, ...revisions] = s.revisions;
          return { main, revisions };
        }),
        page: input.page,
      };
    }),

  verifyOrganizedColumns: protectedProcedure
    .input(organizeColumnRows)
    .mutation(async ({ ctx, input }) => {
      console.log(input);

      const invertOrganizedColumns = Object.entries(input.columns).reduce(
        (a, [k, v]) => ({ ...a, [v]: k }),
        {}
      ) as InvertedObject;

      //Create a list of campuses from the type generated by prisma
      //input.organizeColumns.
      const count = await ctx.prisma.scheduleRevision.count({
        where: { tuid: input.tuid },
      });

      //Check if we have some count
      if (count >= 1) {
        //Grab the revision from the database
        const revision = await ctx.prisma.scheduleRevision.findUnique({
          where: { tuid: input.tuid },
        });
        //Parse the excel file from the database
        //TODO: Make sure this doesn't error out. NOTE: This should be check in the uploadExcel api ideally.
        const results = xlsx.parse(revision?.file);

        //Check if we have the sheet from the file
        if (results[0] != undefined) {
          const sheet = results[0];
          const columns = sheet?.data as ExcelDataColumns;

          const getIndexFromOrganizedColumns = (index: number): string => {
            //have to set type 'unknown as string' so that TS will not get mad
            //we are assuming that we will know the type
            const indexKey = invertOrganizedColumns[index] as unknown as string;
            return indexKey == undefined ? "_" : indexKey;
          };

          /**
           * invertedOrganizedColumns
           * Converts the columns from the inverted key: value to value: key
           * based on the rows provided by the client as a lookup table
           */
          const invertedOrganizedColumns = columns.map(
            (c) =>
              //Reduce each row by adding a new key to each row
              c.reduce(
                (obj, item, index) => ({
                  ...obj,
                  //get the name of the key and set it to the value of the item
                  [getIndexFromOrganizedColumns(index)]: `${item}`,
                }),
                {}
              )
            //make sure the type of this is defined
          ) as IProjectOrganizedColumnRow[];

          console.log({ invertedOrganizedColumns });

          const hasAllColumns = invertedOrganizedColumns.some((row) => {
            return (
              row.noteWhatHasChanged &&
              row.section_id &&
              row.term &&
              row.div &&
              row.department &&
              row.subject &&
              row.course_number &&
              row.section &&
              row.title &&
              row.instruction_method &&
              row.faculty &&
              row.campus &&
              row.credits &&
              row.capacity &&
              row.start_date &&
              row.end_date &&
              row.building &&
              row.room &&
              row.start_time &&
              row.end_time &&
              row.days &&
              row.noteAcademicAffairs &&
              row.notePrintedComments
            );
          });
          console.log({ hasAllColumns });

          const invertedNestedOrganizedColumns = invertedOrganizedColumns.map(
            (c) => {
              if (c.building) {
                //Spread all the data we want to split
                const {
                  _,
                  //@es-ingore
                  end_date,
                  building,
                  room,
                  start_time,
                  end_time,
                  days,
                  //Make sure we get the rest of the data at the end
                  ...everything
                } = c as IProjectOrganizedColumnRow & { _: string };

                //Get the building
                const updatedBuilding = building.split("\n");
                const updatedRoom = room.split("\n");
                //Start time
                const updatedStart_time = start_time
                  .split("\n")
                  .map((c) => c.trim());
                const updatedEnd_time = end_time
                  .split("\n")
                  .map((c) => c.trim());
                const updatedDays = days
                  .trim()
                  .split("\n")
                  .map((c) => c.toLowerCase());

                console.log(updatedDays);

                const result = {
                  locations: [
                    updatedBuilding.reduce((obj, item, index) => {
                      return {
                        ...obj,
                        building: item,
                        room: updatedRoom[index],
                        start_time: updatedStart_time[index],
                        end_time: updatedEnd_time[index],
                      };
                    }, {}),
                  ],
                  day_monday: updatedDays.includes("m"),
                  day_tuesday: updatedDays.includes("t"),
                  day_wednesday: updatedDays.includes("w"),
                  day_thursday: updatedDays.includes("r"),
                  day_friday: updatedDays.includes("f"),
                  day_saturday: updatedDays.includes("sat"),
                  day_sunday: updatedDays.includes("sun"),
                  ...everything,
                };
                console.log(result);
                return result;
              }
            }
          );
        }
      }
      //Do we have a search query

      return true;
    }),
});

interface InvertedObject {
  [key: string]: string;
}
