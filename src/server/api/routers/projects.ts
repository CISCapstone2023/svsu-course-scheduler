import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "src/server/api/trpc";
import { Prisma } from "@prisma/client";
import { prisma } from "src/server/db";
import {
  IProjectOrganizedColumnRow,
  organizeColumnRows,
  type IProjectOrganizedColumnRowNumerical,
  type IProjectOrganizedColumnFromClient,
  createRevisionOnboarding,
} from "src/validation/projects";
import xlsx from "node-xlsx";
import { invert } from "lodash";
import { componentShapes } from "react-daisyui/dist/constants";
import Faculty from "src/pages/dashboard/[scheduleId]/faculty/Faculty";
import { courseSchema, ICourseSchema } from "src/validation/courses";
type ExcelDataColumns = Array<Array<string | undefined>>;

//import validation next
const scheduleWithRevisions = Prisma.validator<Prisma.ScheduleArgs>()({
  include: { revisions: true },
});
type ScheduleWithRevisions = Prisma.ScheduleGetPayload<
  typeof scheduleWithRevisions
>;
export const projectsRouter = createTRPCRouter({
  // ScheduleRevision -------------------------------------------------------------------------------------

  //Get all ScheduleRevisions and display list of schedule revisions sorted by time, desecnding
  getAllScheduleRevisions: protectedProcedure
    .input(
      z.object({
        search: z.string(),
        page: z.number().default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      let scheduleResult: ScheduleWithRevisions[] = [];

      //Do we have a search query
      if (input.search != "") {
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          where: {
            revisions: {
              every: { name: { contains: input.search } },
            },
          },
          include: {
            revisions: true,
          },
        });
      } else {
        //If we don't have a search query don't worry about the filter
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          include: {
            revisions: {
              orderBy: {
                updatedAt: "desc",
              },
            },
          },
        });
      }

      //Return the data
      return {
        result: scheduleResult.map((s) => {
          const [main, ...revisions] = s.revisions;
          return { main, revisions };
        }),
        page: input.page,
      };
    }),

  verifyOrganizedColumns: protectedProcedure
    .input(organizeColumnRows)
    .mutation(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      //input.organizeColumns.
      const count = await ctx.prisma.scheduleRevision.count({
        where: { tuid: input.tuid },
      });

      let verifyColumns = false;
      //Check if we have some count
      if (count >= 1) {
        //Grab the revision from the database
        const revision = await ctx.prisma.scheduleRevision.findUnique({
          where: { tuid: input.tuid },
        });
        //Parse the excel file from the database
        //TODO: Make sure this doesn't error out. NOTE: This should be check in the uploadExcel api ideally.
        const results = xlsx.parse(revision?.file);

        //Check if we have the sheet from the file
        if (results[0] != undefined) {
          const sheet = results[0];
          const columns = sheet?.data as ExcelDataColumns;

          //console.log({ invertedNestedOrganizedColumns });

          const formattedColumns = await invertedNestedOrganizedColumns(
            columns,
            input.columns
          );

          let valid = true;
          let errors: z.ZodError;
          for (const row of formattedColumns) {
            if (row != undefined) {
              const result = courseSchema.safeParse(row);
              //console.log({ result, row, json: JSON.stringify(row) });
              if (result.success == false) {
                valid = false;
                errors = result.error;
                break;
              }
            }
          }
          verifyColumns = valid;
        }
      }
      //Do we have a search query

      return verifyColumns;
    }),
  createScheduleRevision: protectedProcedure
    .input(createRevisionOnboarding)
    .mutation(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      //input.organizeColumns.
      console.log("yes this one");
      const count = await ctx.prisma.scheduleRevision.count({
        where: { tuid: input.tuid },
      });

      //Check if we have some count
      if (count >= 1) {
        //Grab the revision from the database
        const revision = await ctx.prisma.scheduleRevision.findUnique({
          where: { tuid: input.tuid },
        });
        //Parse the excel file from the database
        //TODO: Make sure this doesn't error out. NOTE: This should be check in the uploadExcel api ideally.
        const results = xlsx.parse(revision?.file);

        //Check if we have the sheet from the file
        if (results[0] != undefined) {
          const sheet = results[0];
          const columns = sheet?.data as ExcelDataColumns;

          //console.log({ invertedNestedOrganizedColumns });

          const formattedColumns = await invertedNestedOrganizedColumns(
            columns,
            input.columns
          );

          let valid = true;
          let errors: z.ZodError;

          //Make sure every single course row is safely parsed
          for (const row of formattedColumns) {
            if (row != undefined) {
              const result = courseSchema.safeParse(row);
              //console.log({ result, row, json: JSON.stringify(row) });
              if (result.success == false) {
                valid = false;
                errors = result.error;
                break;
              }
            }
          }
          //Make sure all are valid before we actually enter them all into the database
          if (valid) {
            for (const row of formattedColumns) {
              if (row != undefined) {
                await addCourse(row);
              }
            }
          }
        }
      }
      //Do we have a search query
      return false;
    }),
});

interface InvertedObject {
  [key: string]: string;
}

const addCourse = async (row: Partial<ICourseSchema>) => {
  //add course
  console.log({ title: row.title });
};

const invertedNestedOrganizedColumns = async (
  columns: ExcelDataColumns,
  organizedColumns: IProjectOrganizedColumnRowNumerical
) => {
  const invertOrganizedColumns = Object.entries(organizedColumns).reduce(
    (a, [k, v]) => ({ ...a, [v]: k }),
    {}
  ) as InvertedObject;

  const getIndexFromOrganizedColumns = (index: number): string => {
    //have to set type 'unknown as string' so that TS will not get mad
    //we are assuming that we will know the type
    const indexKey = invertOrganizedColumns[index] as unknown as string;
    return indexKey == undefined ? "_" : indexKey;
  };

  /**
   * invertedOrganizedColumns
   * Converts the columns from the inverted key: value to value: key
   * based on the rows provided by the client as a lookup table
   */
  const invertedOrganizedColumns = columns.splice(1).map(
    (c) =>
      //Reduce each row by adding a new key to each row
      c.reduce(
        (obj, item, index) => ({
          ...obj,
          //get the name of the key and set it to the value of the item
          [getIndexFromOrganizedColumns(index)]: `${item}`,
        }),
        {}
      )
    //make sure the type of this is defined
  ) as IProjectOrganizedColumnRow[];

  const hasAllColumns = invertedOrganizedColumns.every((row) => {
    return (
      row.noteWhatHasChanged &&
      row.section_id &&
      row.term &&
      row.div &&
      row.department &&
      row.subject &&
      row.course_number &&
      row.section &&
      row.title &&
      row.instruction_method &&
      row.faculty &&
      row.campus &&
      row.credits &&
      row.capacity &&
      row.start_date &&
      row.end_date &&
      row.building &&
      row.room &&
      row.start_time &&
      row.end_time &&
      row.days &&
      row.noteAcademicAffairs &&
      row.notePrintedComments
    );
  });

  const invertedNestedOrganizedColumns = await Promise.all(
    invertedOrganizedColumns.map(async (c) => {
      if (c.building) {
        //Spread all the data we want to split
        const {
          _,
          //@es-ingore

          //Make sure we get the rest of the data at the end
          ...data
        } = c as IProjectOrganizedColumnRow & { _: string };

        //Get the building
        const updatedBuilding = data.building.split(/\r\n|\n|\r/);
        const updatedRoom = data.room.split(/\r\n|\n|\r/);
        //Start time
        const updatedStart_time = data.start_time
          .split(/\r\n|\n|\r/)
          .map((c) => c.trim());
        const updatedEnd_time = data.end_time
          .split(/\r\n|\n|\r/)
          .map((c) => c.trim());

        const updatedDays = data.days
          .trim()
          .split(/\r\n|\n|\r/)
          .map((c) => c.toLowerCase());

        const updateFaculty = data.faculty.trim().split(/\r\n|\n|\r/);

        let start_time_updated = 0;
        let end_time_updated = 0;

        const convertTimeToMilitary = (value: string) => {
          let time = "0";
          let minute = 0;
          let hour = 0;
          if (value.includes("PM")) {
            hour += 12;
          }
          const splittedTime = value.split(":");
          if (splittedTime != undefined && splittedTime.length == 2) {
            try {
              hour = parseInt(splittedTime[0] as string);
              minute = parseInt(
                splittedTime[1]!.length > 1
                  ? (splittedTime[1]?.substring(0, 2) as string)
                  : (splittedTime[1]?.substring(0, 1) as string)
              );
            } catch (err) {
              return 0;
            } finally {
              time = `${hour}${minute == 0 ? "00" : minute}`;
            }
          }
          return parseInt(time);
        };

        const getTermYear = (term: string) => {
          return term.split("/")[0]?.toString();
        };

        const getTermSemester = (term: string) => {
          const semester = term.split("/")[1]?.toString().trim();

          return {
            semester_summer: semester === "SU",
            semester_fall: semester === "FA",
            semester_winter: semester === "WI",
            semester_spring: semester === "SP",
          };
        };

        const locations = async () => {
          const value = await Promise.all(
            updatedBuilding.map(async (item, index) => {
              const times = {
                start_time: convertTimeToMilitary(
                  updatedStart_time[index]?.trim() as string
                ),
                end_time: convertTimeToMilitary(
                  updatedEnd_time[index]?.trim() as string
                ),
              };

              start_time_updated = times.start_time;
              end_time_updated = times.end_time;

              const buildingResult = await prisma.guidelineBuilding.findFirst({
                where: {
                  prefix: item,
                },
              });

              return {
                building: item,
                rooms: [
                  ...(item != "ONL"
                    ? [
                        {
                          room: updatedRoom[index],
                          building_tuid: buildingResult?.tuid,
                        },
                      ]
                    : []),
                ],
                ...times,
                is_online: item === "ONL",
                day_monday: updatedDays.includes("m"),
                day_tuesday: updatedDays.includes("t"),
                day_wednesday: updatedDays.includes("w"),
                day_thursday: updatedDays.includes("r"),
                day_friday: updatedDays.includes("f"),
                day_saturday: updatedDays.includes("sat"),
                day_sunday: updatedDays.includes("sun"),
              };
            }, {})
          );
          return value;
        };

        const faculty = async () => {
          const value = await Promise.all(
            updateFaculty.map(async (faculty) => {
              const resultFaculty = await prisma.guidelinesFaculty.findFirst({
                where: {
                  name: faculty.toLowerCase(),
                },
              });
              //console.log({ resultFaculty });
              return {
                faculty_tuid: resultFaculty?.tuid,
              };
            })
          );
          return value;
        };

        const out = {
          section_id: parseInt(data.section_id),
          type: "Unknown",
          term: parseInt(
            getTermYear(data.term) || new Date().getFullYear() + ""
          ),
          ...getTermSemester(data.term),
          div: data.div,
          department: data.department,
          subject: data.subject,
          course_number: data.course_number,
          section: parseInt(data.section) || 0,
          start_date: new Date(
            Date.UTC(0, 0, (parseInt(data.start_date) || 0) - 1)
          ),
          end_date: new Date(
            Date.UTC(0, 0, (parseInt(data.end_date) || 0) - 1)
          ),
          credits: parseInt(data.credits) || 0,
          title: data.title,
          capacity: parseInt(data.capacity) || 0,
          faculty: [...(await faculty())],
          locations: [
            ...(await locations()),
            // {
            //   end_time: 1020,
            //   start_time: 830,
            //   is_online: false,
            //   day_monday: false,
            //   day_tuesday: false,
            //   day_wednesday: false,
            //   day_thursday: false,
            //   day_friday: false,
            //   day_saturday: false,
            //   day_sunday: false,
            //   rooms: [
            //     {
            //       room: "100",
            //     },
            //   ],
            // },
          ],
          notes: [
            {
              note: data.noteAcademicAffairs,
              type: "ACAMDEMIC_AFFAIRS",
            },
            {
              note: data.notePrintedComments,
              type: "DEPARTMENT",
            },
            {
              note: data.noteWhatHasChanged,
              type: "CHANGES",
            },
          ],
        } as Partial<ICourseSchema>;

        //console.log(JSON.stringify(out));
        return out;
      }
    })
  );
  return invertedNestedOrganizedColumns;
};
