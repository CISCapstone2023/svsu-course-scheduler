import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "src/server/api/trpc";
import { Prisma } from "@prisma/client";
import {
  IProjectOrganizedColumnRow,
  organizeColumnRows,
  type IProjectOrganizedColumnFromClient,
} from "src/validation/projects";
import xlsx from "node-xlsx";
import { invert } from "lodash";
import { componentShapes } from "react-daisyui/dist/constants";
import Faculty from "src/pages/dashboard/[scheduleId]/faculty/Faculty";
type ExcelDataColumns = Array<Array<string | undefined>>;

//import validation next
const scheduleWithRevisions = Prisma.validator<Prisma.ScheduleArgs>()({
  include: { revisions: true },
});
type ScheduleWithRevisions = Prisma.ScheduleGetPayload<
  typeof scheduleWithRevisions
>;
export const projectsRouter = createTRPCRouter({
  // ScheduleRevision -------------------------------------------------------------------------------------

  //Get all ScheduleRevisions and display list of schedule revisions sorted by time, desecnding
  getAllScheduleRevisions: protectedProcedure
    .input(
      z.object({
        search: z.string(),
        page: z.number().default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      let scheduleResult: ScheduleWithRevisions[] = [];

      //Do we have a search query
      if (input.search != "") {
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          where: {
            revisions: {
              every: { name: { contains: input.search } },
            },
          },
          include: {
            revisions: true,
          },
        });
      } else {
        //If we don't have a search query don't worry about the filter
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          include: {
            revisions: {
              orderBy: {
                updatedAt: "desc",
              },
            },
          },
        });
      }

      //Return the data
      return {
        result: scheduleResult.map((s) => {
          const [main, ...revisions] = s.revisions;
          return { main, revisions };
        }),
        page: input.page,
      };
    }),

  addProjects: protectedProcedure
    .input(organizeColumnRows)
    .mutation(async ({ ctx, input }) => {
      //Fake testing data for the moment
      const fake = {
        tuid: "cle0ihs8q0003n9ywoup6bxk3",
        organizeColumns: {
          section_id: 1,
          term: 2,
          noteWhatHasChanged: 0,
          div: 3,
          department: 4,
          subject: 5,
          course_number: 6,
          section: 7,
          title: 8,
          instruction_method: 9,
          faculty: 10,
          campus: 11,
          credits: 12,
          capacity: 13,
          start_date: 17,
          end_date: 18,
          building: 20,
          room: 21,
          start_time: 22,
          end_time: 23,
          days: 24,
          noteAcademicAffairs: 27,
          notePrintedComments: 28,
        },
      } as IProjectOrganizedColumnFromClient;

      //invert the key and the value from from the data we recieve
      const invertOrganizedColumns = Object.entries(
        fake.organizeColumns
      ).reduce((a, [k, v]) => ({ ...a, [v]: k }), {}) as InvertedObject;

      console.log(invertOrganizedColumns);
      //Create a list of campuses from the type generated by prisma
      //input.organizeColumns.
      const count = await ctx.prisma.scheduleRevision.count({
        where: { tuid: fake.tuid },
      });

      //Check if we have some count
      if (count >= 1) {
        //Grab the revision from the database
        const revision = await ctx.prisma.scheduleRevision.findUnique({
          where: { tuid: fake.tuid },
        });
        //Parse the excel file from the database
        //TODO: Make sure this doesn't error out. NOTE: This should be check in the uploadExcel api ideally.
        const results = xlsx.parse(revision?.file);

        //Check if we have the sheet from the file
        if (results[0] != undefined) {
          const sheet = results[0];
          const columns = sheet?.data as ExcelDataColumns;

          const getIndexFromOrganizedColumns = (index: number): string => {
            //have to set type 'unknown as string' so that TS will not get mad
            //we are assuming that we will know the type
            const indexKey = invertOrganizedColumns[index] as unknown as string;
            return indexKey == undefined ? "_" : indexKey;
          };

          /**
           * invertedOrganizedColumns
           * Converts the columns from the inverted key: value to value: key
           * based on the rows provided by the client as a lookup table
           */
          const invertedOrganizedColumns = columns.map(
            (c) =>
              //Reduce each row by adding a new key to each row
              c.reduce(
                (obj, item, index) => ({
                  ...obj,
                  //get the name of the key and set it to the value of the item
                  [getIndexFromOrganizedColumns(index)]: `${item}`,
                }),
                {}
              )
            //make sure the type of this is defined
          ) as IProjectOrganizedColumnRow[];

          const invertedNestedOrganizedColumns = invertedOrganizedColumns.map(
            (c) => {
              if (c.building) {
                //Spread all the data we want to split
                const {
                  _,
                  //@es-ingore
                  end_date,
                  building,
                  room,
                  start_time,
                  end_time,
                  days,
                  //Make sure we get the rest of the data at the end
                  ...everything
                } = c as IProjectOrganizedColumnRow & { _: string };

                //Get the building
                const updatedBuilding = building.split("\n");
                const updatedRoom = room.split("\n");
                //Start time
                const updatedStart_time = start_time
                  .split("\n")
                  .map((c) => c.trim());
                const updatedEnd_time = end_time
                  .split("\n")
                  .map((c) => c.trim());
                const updatedDays = days
                  .trim()
                  .split("\n")
                  .map((c) => c.toLowerCase());

                console.log(updatedDays);

                const result = {
                  locations: [
                    updatedBuilding.reduce((obj, item, index) => {
                      return {
                        ...obj,
                        building: item,
                        room: updatedRoom[index],
                        start_time: updatedStart_time[index],
                        end_time: updatedEnd_time[index],
                      };
                    }, {}),
                  ],
                  day_monday: updatedDays.includes("m"),
                  day_tuesday: updatedDays.includes("t"),
                  day_wednesday: updatedDays.includes("w"),
                  day_thursday: updatedDays.includes("r"),
                  day_friday: updatedDays.includes("f"),
                  day_saturday: updatedDays.includes("sat"),
                  day_sunday: updatedDays.includes("sun"),
                  ...everything,
                };
                console.log(result);
                return result;
              }

              return {};
            }
          );

          //https://stackoverflow.com/questions/16229494/converting-excel-date-serial-number-to-date-using-javascript
          //console.log(invertedOrganizedColumns);
          //console.log(JSON.stringify(invertedOrganizedColumns));
        }
      }
      //Do we have a search query
    }),
});

interface InvertedObject {
  [key: string]: string;
}
