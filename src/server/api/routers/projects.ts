import { z } from "zod";

import { createTRPCRouter, protectedProcedure } from "src/server/api/trpc";
import { Prisma } from "@prisma/client";
//import validation next
import { createRevisionSchemaTUID } from "src/validation/projects";
const scheduleWithRevisions = Prisma.validator<Prisma.ScheduleArgs>()({
  include: { revisions: true },
});
type ScheduleWithRevisions = Prisma.ScheduleGetPayload<
  typeof scheduleWithRevisions
>;
export const projectsRouter = createTRPCRouter({
  // ScheduleRevision -------------------------------------------------------------------------------------
  //delete schedule revision
  deleteScheduleRevision: protectedProcedure
    .input(createRevisionSchemaTUID)
    //async mutation to handle the deletion
    .mutation(async ({ ctx, input }) => {
      const hasRevision = await ctx.prisma.scheduleRevision.count({
        //check based on the client input of tuid
        where: {
          creator_tuid: ctx.session.user.id,
          tuid: input.tuid,
        },
      });
      if (hasRevision == 1) {
        await ctx.prisma.scheduleRevision.delete({
          where: {
            tuid: input.tuid,
          },
        });
        return true;
      }
      return false;
    }),

  //Get all ScheduleRevisions and display list of schedule revisions sorted by time, desecnding
  getAllScheduleRevisions: protectedProcedure
    .input(
      z.object({
        search: z.string().optional(),
        page: z.number().default(0),
      })
    )
    .query(async ({ ctx, input }) => {
      //Create a list of campuses from the type generated by prisma
      let scheduleResult: ScheduleWithRevisions[] = [];

      //Do we have a search query
      if (input.search != "") {
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          where: {
            revisions: {
              every: { name: { contains: input.search } },
            },
          },
          include: {
            revisions: true,
          },
        });
      } else {
        //If we don't have a search query don't worry about the filter
        scheduleResult = await ctx.prisma.schedule.findMany({
          //We want 10
          take: 10,
          //We start at 0
          skip: input.page * 10,
          include: {
            revisions: {
              orderBy: {
                updatedAt: "desc",
              },
            },
          },
        });
      }

      //Return the data
      return {
        result: scheduleResult.map((s) => {
          const [main, ...revisions] = s.revisions;
          return {
            main: {
              name: main?.name,
              tuid: main?.tuid,
              updatedAt: main?.updatedAt,
            },
            revisions: revisions.map((revision) => {
              return {
                name: revision?.name,
                tuid: revision?.tuid,
                updatedAt: revision?.updatedAt,
              };
            }),
          };
        }),
        page: input.page,
      };
    }),
});
